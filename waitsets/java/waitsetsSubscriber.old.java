                    

/* waitsetsSubscriber.java

A publication of data of type waitsets

This file is derived from code automatically generated by the rtiddsgen 
command:

rtiddsgen -language java -example <arch> waitsets.idl

Example publication of type waitsets automatically generated by 
'rtiddsgen' To test them follow these steps:

(1) Compile this file and the example subscription.

(2) Start the subscription on the same domain used for RTI Data Distribution
Service with the command
java waitsetsSubscriber <domain_id> <sample_count>

(3) Start the publication on the same domain used for RTI Data Distribution
Service with the command
java waitsetsPublisher <domain_id> <sample_count>

(4) [Optional] Specify the list of discovery initial peers and 
multicast receive addresses via an environment variable or a file 
(in the current working directory) called NDDS_DISCOVERY_PEERS. 
       
You can run any number of publishers and subscribers programs, and can 
add and remove them dynamically from the domain.
              
                                   
Example:
        
To run the example application on domain <domain_id>:
            
Ensure that $(NDDSHOME)/lib/<arch> is on the dynamic library path for
Java.                       
       
On Unix: 
add $(NDDSHOME)/lib/<arch> to the 'LD_LIBRARY_PATH' environment
variable
                                         
On Windows:
add $(NDDSHOME)\lib\<arch> to the 'Path' environment variable
                        

Run the Java applications:
       
java -Djava.ext.dirs=$NDDSHOME/class waitsetsPublisher <domain_id>

java -Djava.ext.dirs=$NDDSHOME/class waitsetsSubscriber <domain_id>  
       
       
modification history
------------ -------   
* Remove listener code

* Decrease requested liveliness lease duration

* Create statuscondition and readcondition,
create waitset and attach condtions

* Wait in subscriber_main loop on waitset,
process wait results
*/

    import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Arrays;

import com.rti.dds.domain.*;
import com.rti.dds.infrastructure.*;
import com.rti.dds.subscription.*;
import com.rti.dds.topic.*;
import com.rti.ndds.config.*;

// ===========================================================================

public class waitsetsSubscriber {
    // -----------------------------------------------------------------------
    // Public Methods
    // -----------------------------------------------------------------------
    
    public static void main(String[] args) {
        // --- Get domain ID --- //
        int domainId = 0;
        if (args.length >= 1) {
            domainId = Integer.valueOf(args[0]).intValue();
        }
        
        // -- Get max loop count; 0 means infinite loop --- //
        int sampleCount = 0;
        if (args.length >= 2) {
            sampleCount = Integer.valueOf(args[1]).intValue();
        }
        
        
        /* Uncomment this to turn on additional logging
           Logger.get_instance().set_verbosity_by_category(
           LogCategory.NDDS_CONFIG_LOG_CATEGORY_API,
           LogVerbosity.NDDS_CONFIG_LOG_VERBOSITY_STATUS_ALL);
        */
        
        // --- Run --- //
        subscriberMain(domainId, sampleCount);
    }
    
    
    
    // -----------------------------------------------------------------------
    // Private Methods
    // -----------------------------------------------------------------------
    
    // --- Constructors: -----------------------------------------------------
    
    private waitsetsSubscriber() {
        super();
    }
    
    
    // -----------------------------------------------------------------------
    
    private static void subscriberMain(int domainId, int sampleCount) {

        DomainParticipant participant = null;
        Subscriber subscriber = null;
        Topic topic = null;
        DataReaderListener listener = null;
        waitsetsDataReader reader = null;

        try {

            // --- Create participant --- //
                       
            /* To create participant with default QoS,
               use DomainParticipantFactory.DomainParticipantFactory.
               participant.get_default_publisher_qos() */
            participant = DomainParticipantFactory.TheParticipantFactory.
                create_participant(
                    domainId, DomainParticipantFactory.PARTICIPANT_QOS_DEFAULT,
                    null /* listener */, StatusKind.STATUS_MASK_NONE);
                    

            // --- Create subscriber --- //

            /* To customize subscriber QoS, use
               participant.get_default_subscriber_qos() */
            subscriber = participant.create_subscriber(
                DomainParticipant.SUBSCRIBER_QOS_DEFAULT, null /* listener */,
                StatusKind.STATUS_MASK_NONE);

            // --- Create topic --- //
        
            /* Register type before creating topic */
            String typeName = waitsetsTypeSupport.get_type_name(); 
            waitsetsTypeSupport.register_type(participant, typeName);

            /* To customize topic QoS, use
               participant.get_default_topic_qos() */
            topic = participant.create_topic(
                "Example waitsets",
                typeName, DomainParticipant.TOPIC_QOS_DEFAULT,
                null /* listener */, StatusKind.STATUS_MASK_NONE);
        
            // --- Create reader --- //

            //// Start changes for Waitsets

            // No listener needed

            /* Get default datareader QoS to customize */
            DataReaderQos datareader_qos = new DataReaderQos();
            subscriber.get_default_datareader_qos(datareader_qos);

            datareader_qos.liveliness.lease_duration.sec = 2;
            datareader_qos.liveliness.lease_duration.nanosec = 0;

            /* To create datareader with default QoS, use Subscriber.DATAREADER_QOS_DEFAULT
               instead of datareader_qos */
            reader = (waitsetsDataReader)
                subscriber.create_datareader(
                    topic, datareader_qos, null,
                    StatusKind.STATUS_MASK_NONE);
        
            // Create readcondition
            // Note that the readconditions are dependent on both incoming
            // data as well as sample state.  Thus, this method has more
            // overhead than adding a DATA_AVAILABLE_STATUS statuscondition.
            // We show it here purely for reference

            ReadCondition read_condition = reader.create_readcondition(
                SampleStateKind.NOT_READ_SAMPLE_STATE,
                ViewStateKind.ANY_VIEW_STATE,
                InstanceStateKind.ANY_INSTANCE_STATE);

            // Create status condition
            StatusCondition status_condition = reader.get_statuscondition();

            // Since a single status condition can match many statuses, 
            // enable only those we're interested in.
            status_condition.set_enabled_statuses(
                StatusKind.SUBSCRIPTION_MATCHED_STATUS |
                StatusKind.LIVELINESS_CHANGED_STATUS);

            // Create WaitSet, and attach conditions
            WaitSet waitset = new WaitSet();            
            waitset.attach_condition(read_condition);
            waitset.attach_condition(status_condition);

            // --- Wait for data --- //

            Duration_t duration = new Duration_t(1, 500000000);
            int count = 0;
            // Process data
            
            while (sampleCount == 0 || count < sampleCount) {
                ConditionSeq active_conditions = new ConditionSeq();
                try {
                    // The triggered condition(s) will be placed in active_conditions
                    waitset.wait(active_conditions, duration);
                } catch (RETCODE_TIMEOUT e) {
                    System.out.print("wait timed out\n");
                    count+=2;
                    continue;
                }

                // See which conditions triggered
                System.out.print("got " + active_conditions.size() + " active conditions\n");
                for (int i = 0; i < active_conditions.size(); ++i) {
                    if (active_conditions.get(i) == status_condition) {
                        // A status condition triggered--see which ones
                        int triggeredmask = reader.get_status_changes();

                        if ((triggeredmask & StatusKind.LIVELINESS_CHANGED_STATUS) != 0) {
                            LivelinessChangedStatus st = new LivelinessChangedStatus();
                            reader.get_liveliness_changed_status(st);
                            System.out.print("   Liveliness changed.  active writers = "
                                             + st.alive_count + "\n");
                        }

                        if ((triggeredmask & StatusKind.SUBSCRIPTION_MATCHED_STATUS) !=0) {
                            SubscriptionMatchedStatus st = new SubscriptionMatchedStatus();
                            reader.get_subscription_matched_status(st);
                            System.out.print("   Subscription matched.  cumulative matches = "
                                             + st.total_count + "\n");
                        }
                    } else if (active_conditions.get(i) == read_condition) {
                        // OK -- Got data, let's look at it.  At this point it's the
                        // same as reading data any other way.
                        waitsetsSeq data_seq = new waitsetsSeq();
                        SampleInfoSeq info_seq = new SampleInfoSeq();

                        reader.take_w_condition(
                            data_seq, info_seq,
                            ResourceLimitsQosPolicy.LENGTH_UNLIMITED,
                            read_condition);

                        for (int j = 0; j < info_seq.size(); ++j) {
                            if (!((SampleInfo)info_seq.get(j)).valid_data) {
                                System.out.print("   Got metadata\n");
                                continue;
                            }
                            count++;
                            waitsets data = (waitsets)data_seq.get(j);
                            System.out.println("   x: " + data.x);

                        }
                        reader.return_loan(data_seq, info_seq);
                    }
                }
            }
        } finally {

            // --- Shutdown --- //

            if(participant != null) {
                participant.delete_contained_entities();

                DomainParticipantFactory.TheParticipantFactory.
                    delete_participant(participant);
            }
            /* RTI Data Distribution Service provides finalize_instance()
               method for people who want to release memory used by the
               participant factory singleton. Uncomment the following block of
               code for clean destruction of the participant factory
               singleton. */
            //DomainParticipantFactory.finalize_instance();
        }
    }
    
    // -----------------------------------------------------------------------
    // Private Types
    // -----------------------------------------------------------------------
    
    // =======================================================================
    
    private static class waitsetsListener extends DataReaderAdapter {
            
        waitsetsSeq _dataSeq = new waitsetsSeq();
        SampleInfoSeq _infoSeq = new SampleInfoSeq();

        public void on_data_available(DataReader reader) {
            waitsetsDataReader waitsetsReader =
                (waitsetsDataReader)reader;
            
            try {
                waitsetsReader.take(
                    _dataSeq, _infoSeq,
                    ResourceLimitsQosPolicy.LENGTH_UNLIMITED,
                    SampleStateKind.ANY_SAMPLE_STATE,
                    ViewStateKind.ANY_VIEW_STATE,
                    InstanceStateKind.ANY_INSTANCE_STATE);

                for(int i = 0; i < _dataSeq.size(); ++i) {
                    SampleInfo info = (SampleInfo)_infoSeq.get(i);

                    if (info.valid_data) {
                        System.out.println(
                            ((waitsets)_dataSeq.get(i)).toString("Received",0));


                    }
                }
            } catch (RETCODE_NO_DATA noData) {
                // No data to process
            } finally {
                waitsetsReader.return_loan(_dataSeq, _infoSeq);
            }
        }
    }
}

